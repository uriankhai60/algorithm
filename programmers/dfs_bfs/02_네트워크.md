### 링크  
https://school.programmers.co.kr/learn/courses/30/lessons/43162
  
---  

### 스코어    
품: 0  
못품: 2  
중요도: DFS기본을 볼수 있는 문제 중요함  
  
---  
  
### 아이디어  
초기 주어지는 자료구조가 눈에 들어와서 잘 떠오르지가 않는다.  
DFS문제인 것 같기는 한데...  
네트워크의 개수를 N으로 초기값으로 잡아야 할 것 같고.  
어디서부터 물고 들어가야 할지 모르겠다.  
  
---  
  
### 해설  
컴퓨터들을 노드로 보고, 연결정보를 간선이라고 생각한다.  
하나의 노드에서 방문가능한 노드들을 하나의 네트워크라고 간주한다.  
방문 리스트를 만들고 -> 연결된 노드들을 방문 표시 -> 네트워크 개수 +1  
모든 컴퓨터를 방문하면 덩어리가 몇개인지 알 수 있다.  
  
---
  
### 풀이  
```python
def solution(n, computers):
    visited = [False] * n # 방문 리스트
    cnt = 0
    
    # 연관된곳을 방문처리하는 dfs함수
    def dfs(idx):
        # 들어온곳 방문처리
        visited[idx] = True
        # 이어진곳 dfs
        for nxt in range(n):
            if computers[idx][nxt] == 1 and not visited[nxt]:
                dfs(nxt)
    
    # 모든 인덱스마다 확인
    for idx in range(n):
        # 방문 안했다면
        if not visited[idx]:
            # 해당 인덱스부터 dfs
            dfs(idx)
            # 카운트 올리기
            cnt+=1
    
    answer = cnt
    return answer
```

```python
def solution(n, computers):
    visited = [False] * n # 방문리스트
    cnt = 0
    
    # 방문
    def dfs(cur_pc):
        # 방문처리
        visited[cur_pc] = True
        # 다른인덱스 돌면서 연결되어있는경우 dfs 처리
        for other_pc in range(n):
            is_connected = computers[cur_pc][other_pc]
            if is_connected and not visited[other_pc]:
                dfs(other_pc)
    
    # 인덱스별로 루프
    for pc in range(n):
        # 방문한적이 없으면
        if not visited[pc]:
            # 카운트 올리고 해당 노드부터 dfs 처리
            dfs(pc)
            cnt+=1
    
    answer = cnt
    return answer

```