### 링크  
https://school.programmers.co.kr/learn/courses/30/lessons/1844  
  
---  
  
### 스코어   
품: 1  
못품: 1  
중요도: 매우 중요해 보임**  

---  
  
### 아이디어  
모든 경우의 수를 계산하는 BFS로직이 적합함은 이해가 간다.  
하지만, 하나의 map에 방문 스텝을 기록하면 꼬이게 될것 같다.  
그러면, map을 메모장처럼 쓰면 될것 같은데.  
BFS에서 벽을 만났을때 어떻게 처리해야할까...  
  
---  
  
### 해설  
내가 잘못생각했다.  
BFS는 DFS와 달리 재귀가 필요없고 dq만으로 로직 설계가 가능한 문제이다.  
미리 준비해야 할 것은  
dq, visited, direction 행렬이다.  
dq와 visited에 초기값을 설정하고
dq에서 값을 뽑아쓰면서  
종료조건과 이동조건을 탐색하면서 dq에 추가.    

---  
  
### 풀이  
```python
from collections import deque

def solution(maps):
    n = len(maps) # 세로
    m = len(maps[0]) # 가로
    
    visited = [[False] * m for _ in range(n)]
    visited[0][0] = True
    
    dq = deque([(0, 0, 1)]) # 초기값 셋팅
    
    # 상하좌우 이동 정의
    directions = [(-1, 0), (+1, 0), (0, +1), (0, -1)]
    
    while dq:
        # 팝
        y, x, cur_step = dq.popleft()
        
        # 종료조건 확인
        if y == n-1 and x == m-1:
            return cur_step
        
        # 모든 방향을 돌면서
        for dy, dx in directions:
            ny = y + dy
            nx = x + dx
            
            # 유효한 영역에 있고
            if (0<=ny<n) and (0<=nx<m):
                
                # 갈수있는 길이며 방문안한 곳이면 방문 처리
                if (maps[ny][nx]==1) and (not visited[ny][nx]):
                    visited[ny][nx] = True
                    new_step = cur_step + 1
                    dq.append((ny, nx, new_step))
                
    return -1
```  
  
```python
'''
BFS 문제

BFS는 deque를 사용하는것이 일반적
visited 행렬을 사용
'''
from collections import deque
def solution(maps):
    n = len(maps)
    m = len(maps[0])
    directions = [(-1,0), (+1,0), (0,-1), (0,+1)]
    visited = [[0] * m for _ in range(n)]
    visited[0][0] = 1
    
    dq = deque([(0,0)])
    
    while dq:
        y, x = dq.popleft()
        
        if y == n-1 and x == m-1:
            return visited[y][x]
        
        for dy, dx in directions:
            ny = y + dy
            nx = x + dx
            # 범위 내부에서
            if 0<=ny<n and 0<=nx<m:
                # 방문가능한 지역이고 방문 안했으면
                if maps[ny][nx] == 1 and not visited[ny][nx]:
                    # 큐에 탐색영역 추가
                    dq.append((ny, nx))
                    # 방문값 증가
                    visited[ny][nx] = visited[y][x] + 1
        

    
    return -1
```  
  
---  