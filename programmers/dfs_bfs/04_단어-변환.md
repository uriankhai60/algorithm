### 링크  
https://school.programmers.co.kr/learn/courses/30/lessons/43163  
  
---  
  
### 스코어   
품: 1  
못품: 0  
중요도: BFS의 문제로 중요해보임**    
---  
  
### 아이디어  
가장 짧은 변환 과정  
병렬로 진행해서 가장 최소값을 찾는 BFS가 적당  
BFS는 deque를 쓰면 되더라  
visited를 일단 잡고하자.  
bfs는 다시 최단경로가 보장되므로 방문을 했으면  
크기 비교가 진행될 필요가 없다고 함(중요!).  
  
---  
  
### 해설  
...  
  
---  
  
### 풀이  
```python
from collections import deque

def calc_distance(a, b):
    my_list = []
    for c1, c2 in zip(a,b):
        tag = True if abs(ord(c1) - ord(c2)) else False
        my_list.append(tag)
    return sum(my_list)

def solution(begin, target, words):
    if target not in words:
        return 0
    
    distances = {word:0 for word in words}
    distances[begin] = 0

    cur_step = 0
    dq = deque([begin])
    while dq:
        cur_word = dq.popleft()
        for dst_word in words:
            dist = calc_distance(cur_word, dst_word)
            # 거리가 1이고
            if dist == 1:
                # 방문한적이 있다면 그냥 넘긴다
                if distances[dst_word] != 0:
                    continue
                    
                # 방문한적이 없다면 스텝수 기록하고 큐에 추가
                else:
                    distances[dst_word] = distances[cur_word] + 1
                    dq.append(dst_word)
    
    answer = distances[target]
    return answer
```  
  
---  