스코어  
- PASS: 1  
- FAIL: 0  
  
아이디어  
완전 탐색으로 접근해보자.  
product를 이용해서 부호의 모든 경우(signs)를 구하고  
모든 signs를 numbers와 곱해서 총 합을 구하고  
그것이 target과 일치할 경우 카운트를 올리자.  
  
내 풀이  
```python
from itertools import product
def solution(numbers, target):
    n = len(numbers)
    signs = list(product([1,-1], repeat=n)) # 2^n
    
    cnt = 0
    
    for sign in signs: # 2^n
        value = sum([i*j for i,j in zip(numbers, sign)]) # 3n -> n
        if value == target:
            cnt+=1
    # 시간복잡도 n *2^n
            
    answer = cnt
    return answer
```  

gpt의 도움을 받아 BFS로 푼 방법의 아이디어는 다음과 같다.  
아이디어의 핵심은 모든 경우를 dq에 넣어서 각 각 스텝별로 *2배씩 경우를 늘리자는 아이디어이다.  
솔직히 직관적이지 않으며 가독성도 좋지 않으나.  
시간 복잡도 측면에서 유리해보인다.  
  
```python
from collections import deque

def solution(numbers, target):
    dq = deque()
    
    # 초기화
    dq.append((0,0)) # 첫번째는 합, 두번째는 인덱스
    cnt = 0
    
    # 시간복잡도는 2^n
    while dq:
        cur_sum, idx = dq.popleft()
        
        # 모든 숫자를 다 사용했다면
        if idx == len(numbers):
            if cur_sum == target:
                cnt+=1
            continue
        
        
        # 인덱스의 숫자 가져옴
        num = numbers[idx]
        # num을 더한경우
        dq.append((cur_sum+num, idx+1))
        # num을 뺀 경우
        dq.append((cur_sum-num, idx+1))
        

    answer = cnt
    return answer
```
